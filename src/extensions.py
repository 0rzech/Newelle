import sys, importlib, os, json, shutil

from gi.repository import Gtk


class NewelleExtension:
    """The base class for all extensions"""
    
    # Name and ID of the extension
    # Name and ID must be less than 50 characters
    name = "Demo Extension"
    id = "demoextension"

    def __init__(self, pip_path : str, extension_path: str, settings):
        """
        Initialize the extension. No resource consuming action should be done on initialization

        Args:
            settings (): Gio application settings
            pip_path: path to the pip directory 
            extension_path: path to the extension cache directory 
        """
        self.pip_path = pip_path
        self.extension_path = extension_path
        self.settings = settings
        pass

    def install(self):
        """Function called on another thread every time the extension is enabled from the settings"""
        pass

    def get_llm_handlers(self) -> list[dict]:
        """
        Returns the list of LLM handlers

        Returns: 
            list: list of LLM handlers in this format
            {
                "key": "key of the handler",
                "title": "title of the handler",
                "description": "description of the handler",
                "class": LLMHanlder - The class of the handler,
            } 
        """
        return [] 

    def get_tts_handlers(self) -> list[dict]:
        """
        Returns the list of TTS handlers

        Returns: 
            list: list of TTS handlers in this format
            {
                "key": "key of the handler",
                "title": "title of the handler",
                "description": "description of the handler",
                "class": TTSHandler - The class of the handler,
            }
            
        """
        return [] 

    def get_stt_handlers(self) -> list[dict]:
        """
        Returns the list of STT handlers

        Returns:
            list: list of STT handlers in this format
            {
                "key": "key of the handler",
                "title": "title of the handler",
                "description": "description of the handler",
                "class": STTHandler - The class of the handler,
            }
        """
        return [] 

    def get_additional_prompts(self) -> list:
        """
        Returns the list of additional prompts

        Returns:
            list: list of additional prompts in this format
            {
                "key": "key of the prompt",
                "setting_name": "name of the settings that gets toggled",
                "title": "Title of the prompt to be shown in settings",
                "description": "Description of the prompt to be shown in settings",
                "editable": bool, If the user can edit the prompt
                "show_in_settings": bool If the prompt should be shown in the settings,
                "default": bool, default value of the setting
                "text": "Default Text of the prompt"
            }            
        """
        return []

    def get_replace_codeblocks_langs(self) -> list:
        """Get the list of codeblock langs that the extension handles and replaces

        Returns:
            list: list of codeblock langs that the extension handles and replaces 
        """
        return []

    def get_gtk_widget(self, codeblock: str, lang: str) -> Gtk.Widget | None: 
        """
        Returns the GTK widget to be shown in the chat, optional

        Args:
            codeblock: str: text in the codeblock generated by the llm
            lang: str: language of the codeblock

        Returns:
            Gtk.Widget: widget to be shown in the chat or None if not provided 
        """
        return None

    def get_answer(self, codeblock: str, lang: str) -> str | None:
        """
        Returns the answer to the codeblock

        Args:
            codeblock: str: text in the codeblock generated by the llm 
            lang: str: language of the codeblock 

        Returns:
            str: answer to the codeblock (will be given to the llm) or None if not provided
        """
        return None


class ExtensionLoader:
    def __init__(self, extension_dir, project_dir=None, pip_path="", extension_cache="", settings=None):
        self.extension_dir = extension_dir
        if project_dir is not None:
            self.project_dir = project_dir
        else:
            self.project_dir = os.path.dirname(os.path.abspath(__file__))
        self.pip = pip_path
        self.extension_cache = extension_cache
        self.settings = settings
    
        if self.settings is None:
            self.extensions_settings = {}
        else:
            self.extensions_settings = json.loads(self.settings.get_string("extensions-settings"))

        self.extensions : list[NewelleExtension] = []
        self.disabled_extensions : list[NewelleExtension] = []
        self.codeblocks : dict[str, NewelleExtension] = {}
        self.filemap : dict[str, str] = {}

    def get_extensions(self) -> list[NewelleExtension]:
        return self.extensions

    def load_extensions(self):

        sys.path.insert(0, self.project_dir)
        for file in os.listdir(self.extension_dir):
            if file.endswith(".py"):
                spec = importlib.util.spec_from_file_location("newelle.name", os.path.join(self.extension_dir, file))
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)

                for class_name, class_obj in module.__dict__.items():
                    if isinstance(class_obj, type) and issubclass(class_obj, NewelleExtension) and class_obj != NewelleExtension:
                        extension = class_obj(self.pip, self.extension_cache, self.settings)
                        # Create entry in settings
                        if extension not in self.extensions_settings:
                            self.extensions_settings[extension.id] = {}
                            self.save_settings()

                        # Save properties about enabled and codeblocks
                        if extension.id in self.extensions_settings and ("disabled" not in self.extensions_settings[extension.id] or not self.extensions_settings[extension.id]["disabled"]):
                            for lang in extension.get_replace_codeblocks_langs():
                                if lang not in self.codeblocks:
                                    self.codeblocks[lang] = extension
                        else:
                            self.disabled_extensions.append(extension)
                        self.extensions.append(extension)
                        self.filemap[extension.id] = file
        sys.path.remove(self.project_dir)

    def add_handlers(self, AVAILABLE_LLMS, AVAILABLE_TTS, AVAILABLE_STT):
        for extension in self.extensions:
            if extension in self.disabled_extensions:
                continue
            handlers = extension.get_llm_handlers()
            for handler in handlers:
                AVAILABLE_LLMS[handler["key"]] = handler
            handlers = extension.get_tts_handlers()
            for handler in handlers:
                AVAILABLE_TTS[handler["key"]] = handler
            handlers = extension.get_stt_handlers()
            for handler in handlers:
                AVAILABLE_STT[handler["key"]] = handler 

    def add_prompts(self, PROMPTS, AVAILABLE_PROMPTS):
        for extension in self.extensions:
            if extension in self.disabled_extensions:
                continue
            prompts = extension.get_additional_prompts()
            for prompt in prompts:
                if prompt not in AVAILABLE_PROMPTS:
                    AVAILABLE_PROMPTS.append(prompt)
                PROMPTS[prompt["key"]] = prompt["text"]

    def remove_extension(self, extension : NewelleExtension | str):
        if not isinstance(extension, str):
            extension = extension.id
        os.remove(os.path.join(self.extension_dir, self.filemap[extension]))

    def add_extension(self, file_path : str):
        shutil.copyfile(file_path, os.path.join(self.extension_dir, os.path.basename(file_path)))

    def get_extension_by_id(self, id: str) -> NewelleExtension | None:
        for extension in self.extensions:
            if extension.id == id:
                return extension

    def enable(self, extension : NewelleExtension | str):
        if not isinstance(extension, str):
            extension = extension.id
        self.extensions_settings[extension]["disabled"] = False
        self.save_settings()

    def disable(self, extension : NewelleExtension | str):
        if not isinstance(extension, str):
            extension = extension.id
        self.extensions_settings[extension]["disabled"] = True
        self.save_settings()

    def save_settings(self):
        self.settings.set_string("extensions-settings", json.dumps(self.extensions_settings))
